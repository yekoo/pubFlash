package{	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.display.Loader;	import flash.geom.Rectangle;	import flash.geom.Point;		import flash.events.Event;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.net.URLRequest;			public class BitmapClip extends Sprite	{		private var frameBitmaps:Vector.<Bitmap>;		private var clipSize:int;		private var frameRectangle:Rectangle;		private var framePoint:Point = new Point();		private var plaingFrameCounter:int = 0;		private var alph:Boolean = false;		private var timer:Timer;		private var timerGap:int = 200;		private var _loopType:String = PLAY_LOOP;		private var pendDir:int = 1;				public static const PLAY_PENDULUM:String = "play_pendulum_animation";		public static const PLAY_ONCE:String = "play_once_animation";		public static const PLAY_LOOP:String = "play_infinite_animation";				public function set loopType(str:String):void{_loopType = str;}				public function BitmapClip(bm:*, alph:Boolean = false, framerate:int = 0)//, frameNum:int);		{			//думаю, для экономии объема файла картинки можно сделать еще один параметр в конструкторе - количество кадров в картинке			//так можно будет избежать огромных пустых "полей" по бокам объекта: 		  //clipSize = bm.width / frameNum;			this.alph = alph;			if(framerate > 0)				timerGap = framerate;						if(bm is String)				loadBitmap(bm);			else				refineBitmap(bm);		}				public function gotoStop(num:int):void		{			timer.stop();			var curFrame:Bitmap = getChildAt(0) as Bitmap;			removeChild(curFrame);						plaingFrameCounter = num-1;			var nextFrame:Bitmap = frameBitmaps[plaingFrameCounter];			addChild(nextFrame);		}		public function gotoPlay(num:int):void		{			plaingFrameCounter = num-1;			var nextFrame:Bitmap = frameBitmaps[plaingFrameCounter];						timer.start();		}		public function play():void		{			timer.start();		}		public function stop():void		{			timer.stop();		}								private function loadBitmap(str:String):void		{			var loader:Loader = new Loader();			loader.load(new URLRequest(str));			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, bitmapLoaded);		}		private function bitmapLoaded(e:Event):void		{			var cont:Bitmap = e.target.content;	trace(cont.width);			refineBitmap(cont);		}				private function refineBitmap(bm:Bitmap):void		{			clipSize = bm.height;			frameRectangle = new Rectangle(0, 0, clipSize, clipSize);			var bmd:BitmapData = new BitmapData(bm.width, bm.height);			bmd.draw(bm);			if(alph)				bmd.floodFill(0,0, 0);						frameBitmaps = new Vector.<Bitmap>;			var frameCount:int = bm.width / bm.height;			for(var i:int = 0; i < frameCount; i++)			{				var frame:Bitmap = cutBitmap(bmd, i);				frameBitmaps.push(frame);			}			addChild(frameBitmaps[0]);			timer = new Timer(timerGap);			timer.addEventListener(TimerEvent.TIMER, playFrameUpdate);	//	,true			timer.start();		}		private function cutBitmap(bmd:BitmapData, index:int):Bitmap		{			frameRectangle.x = clipSize * index;			var frameBmd:BitmapData = new BitmapData(clipSize, clipSize);			frameBmd.copyPixels(bmd, frameRectangle, framePoint);			var frame:Bitmap = new Bitmap(frameBmd);			return frame;		}		private function playFrameUpdate(e:TimerEvent):void		{			loopFrameUpdater();						if(timer.running){				var curFrame:Bitmap = getChildAt(0) as Bitmap;				removeChild(curFrame);							var nextFrame:Bitmap = frameBitmaps[plaingFrameCounter];				addChild(nextFrame);			}			e.updateAfterEvent();		}		private function loopFrameUpdater():void//cnt:int		{			switch(_loopType){				case PLAY_LOOP:					plaingFrameCounter = plaingFrameCounter >= frameBitmaps.length-1 ? 0 : plaingFrameCounter + 1;					break;				case PLAY_ONCE:					plaingFrameCounter++;					if(plaingFrameCounter >= frameBitmaps.length)						timer.stop();					break;				case PLAY_PENDULUM:					if(plaingFrameCounter >= frameBitmaps.length-1) pendDir = -1;					if(plaingFrameCounter <= 0) pendDir = 1;					plaingFrameCounter += pendDir;					break;			}		}	}}